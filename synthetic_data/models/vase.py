from typing import Tuple
import numpy as np
from .base import PhantomGenerator


class Vase(PhantomGenerator):
    """
    A simple rotationally symmetric vase with narrow neck and flared rim.
    Hollow inside with uniform wall thickness.

    * Code generated by Grok.
    """
    def generate(
        self,
        size: int = 256,
        base_radius: float = 0.22,      # radius at bottom (normalized 0~1)
        neck_radius: float = 0.09,      # radius at narrowest point
        rim_radius: float = 0.26,       # radius at top opening
        neck_height: float = 0.38,      # height fraction where neck is narrowest (0~1)
        total_height: float = 0.92,     # total occupied height (leave some top open)
        wall_thickness: float = 0.045,  # wall thickness in normalized units
    ) -> np.ndarray:
        """
        Generate a voxelized vase (hollow with wall).

        Args:
            size: Output voxel grid size (cubic: size×size×size)
            base_radius: Bottom radius (larger value → wider base)
            neck_radius: Minimum radius at the neck
            rim_radius: Top rim radius (flare)
            neck_height: Height fraction (0~1) where the narrowest point occurs
            total_height: Fraction of height the vase occupies (top is open)
            wall_thickness: Thickness of the vase wall (normalized)

        Returns:
            Binary voxel array, dtype=uint8, 1 = vase wall, 0 = empty space
            Shape: (size, size, size)
        """
        voxel = self.get_blank_voxel(size)
        center = size // 2

        # Normalized coordinates [-1, 1]
        zz, yy, xx = np.ogrid[:size, :size, :size]
        X = (xx - center) / (size * 0.5)
        Y = (yy - center) / (size * 0.5)
        Z = (zz - center) / (size * 0.5)

        # Height from bottom: 0 = bottom, 1 = top
        h = (Z + 1.0) / 2.0

        # Only generate below total_height
        in_height = h <= total_height

        # Radius as function of height (piecewise linear + some curve)
        # Bottom → neck → rim
        r = np.zeros_like(h)

        # Bottom part: convex curve widening down
        mask_bottom = h <= neck_height
        r[mask_bottom] = base_radius * (1 - h[mask_bottom] / neck_height) ** 1.5 \
                       + neck_radius * (h[mask_bottom] / neck_height)

        # Neck to rim: linear flare
        mask_upper = (h > neck_height) & in_height
        t = (h[mask_upper] - neck_height) / (total_height - neck_height)
        r[mask_upper] = neck_radius * (1 - t) + rim_radius * t

        # Main cylinder condition
        inside = (X**2 + Y**2) <= r**2
        outside_inner = (X**2 + Y**2) >= (r - wall_thickness)**2

        # Wall = inside outer surface but outside inner surface + height constraint
        wall_mask = inside & outside_inner & in_height

        # Optional: slightly close the very bottom to make it solid at base
        bottom_slice = (h < 0.015) & inside
        wall_mask[bottom_slice] = True

        voxel[wall_mask] = 1
        return voxel