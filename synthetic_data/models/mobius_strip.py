from typing import Tuple, List, Optional

import numpy as np

from .base import PhantomGenerator


class MobiusStrip(PhantomGenerator):
    """
    A Möbius strip.

    * Code generated by Grok. It is actually NOT a mobius strip but still interesting, so I keep it :-)
    """
    def generate(
            self, size: int = 256, radius: int = 100, width: int = 20, thickness: float = 1.0,
    ):
        """ Generate a voxel representation of a Möbius strip.

        Args:
            size: the size of the voxel.
            radius: the radius of the Möbius strip.
            width: the width of the strip.
            thickness: the half-thickness of the strip.

        Returns:
            shape=(size, size, size), dtype=uint8, 0 or 1
        """
        voxel = self.get_blank_voxel(size)

        center = size // 2

        num_theta = 2000
        num_phi = 200
        num_psi = 5 if thickness > 0 else 1

        theta = np.linspace(0, 2 * np.pi, num_theta)
        phi = np.linspace(-width / 2, width / 2, num_phi)

        phi_grid, theta_grid = np.meshgrid(phi, theta)  # Shape (num_theta, num_phi), but transpose for convenience
        phi_grid = phi_grid.T  # Now (num_phi, num_theta)
        theta_grid = theta_grid.T  # (num_phi, num_theta)

        c = np.cos(theta_grid / 2)
        s = np.sin(theta_grid / 2)
        cos_th = np.cos(theta_grid)
        sin_th = np.sin(theta_grid)

        # Position on surface
        x = (radius + phi_grid * c) * cos_th
        y = (radius + phi_grid * c) * sin_th
        z = phi_grid * s

        # Partial derivatives
        term1 = radius + phi_grid * c
        partial_theta_x = -term1 * sin_th - phi_grid * (s / 2) * cos_th
        partial_theta_y = term1 * cos_th - phi_grid * (s / 2) * sin_th
        partial_theta_z = phi_grid * (c / 2)

        partial_phi_x = c * cos_th
        partial_phi_y = c * sin_th
        partial_phi_z = s

        # Cross product for normal
        nx = partial_theta_y * partial_phi_z - partial_theta_z * partial_phi_y
        ny = partial_theta_z * partial_phi_x - partial_theta_x * partial_phi_z
        nz = partial_theta_x * partial_phi_y - partial_theta_y * partial_phi_x

        norm = np.sqrt(nx**2 + ny**2 + nz**2) + 1e-8
        nx /= norm
        ny /= norm
        nz /= norm

        # Add thickness along normal
        psis = np.linspace(-thickness, thickness, num_psi)
        for ps in psis:
            xp = x + ps * nx + center
            yp = y + ps * ny + center
            zp = z + ps * nz + center

            ixp = np.round(xp).astype(int)
            iyp = np.round(yp).astype(int)
            izp = np.round(zp).astype(int)

            valid = ((0 <= ixp) & (ixp < size) &
                     (0 <= iyp) & (iyp < size) &
                     (0 <= izp) & (izp < size))

            voxel[izp[valid], iyp[valid], ixp[valid]] = 1

        return voxel